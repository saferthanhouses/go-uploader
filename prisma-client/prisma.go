// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.
package prisma

import (
	"context"
	"fmt"
	"reflect"
	"strconv"

	"github.com/machinebox/graphql"
	"github.com/mitchellh/mapstructure"
)

// ID docs
type ID struct{}

// Queries

// Exists

// Comment exists docs
func (exists *Exists) Comment(params *CommentWhereUniqueInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "`http://localhost:4466`"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.Comment(
		params,
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// CommentParams docs
type CommentParams struct {
	Where *CommentWhereUniqueInput `json:"where"`
}

// Comment docs - generated while printing operation - query
func (client Client) Comment(params *CommentWhereUniqueInput) *CommentExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CommentWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "comment",
		Field: GraphQLField{
			Name:       "comment",
			TypeName:   "Comment",
			TypeFields: []string{"id", "createdAt", "text"},
		},
		Operation: "query",
		Args:      args,
	})

	return &CommentExec{
		client: client,
		stack:  stack,
	}
}

// CommentsParams docs
type CommentsParams struct {
	Where   *CommentWhereInput   `json:"where,omitempty"`
	OrderBy *CommentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Comments docs - generated while printing operation - query
func (client Client) Comments(params *CommentsParams) *CommentExecArray {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CommentWhereInput",
			Value:    *params.Where,
		})
	}
	if params != nil && params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "CommentOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params != nil && params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params != nil && params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params != nil && params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params != nil && params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params != nil && params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "comments",
		Field: GraphQLField{
			Name:       "comments",
			TypeName:   "Comment",
			TypeFields: []string{"id", "createdAt", "text"},
		},
		Operation: "query",
		Args:      args,
	})

	return &CommentExecArray{
		client: client,
		stack:  stack,
	}
}

// Exists

// CommentsConnection exists docs
func (exists *Exists) CommentsConnection(params *CommentWhereInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "`http://localhost:4466`"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.CommentsConnection(
		&CommentsConnectionParams{
			Where: params,
		},
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// CommentsConnectionParams docs
type CommentsConnectionParams struct {
	Where   *CommentWhereInput   `json:"where,omitempty"`
	OrderBy *CommentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// CommentsConnection docs - generated while printing operation - query
func (client Client) CommentsConnection(params *CommentsConnectionParams) *CommentConnectionExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CommentWhereInput",
			Value:    *params.Where,
		})
	}
	if params != nil && params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "CommentOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params != nil && params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params != nil && params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params != nil && params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params != nil && params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params != nil && params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "commentsConnection",
		Field: GraphQLField{
			Name:       "commentsConnection",
			TypeName:   "CommentConnection",
			TypeFields: []string{},
		},
		Operation: "query",
		Args:      args,
	})

	return &CommentConnectionExec{
		client: client,
		stack:  stack,
	}
}

// Exists

// Request exists docs
func (exists *Exists) Request(params *RequestWhereUniqueInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "`http://localhost:4466`"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.Request(
		params,
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// RequestParams docs
type RequestParams struct {
	Where *RequestWhereUniqueInput `json:"where"`
}

// Request docs - generated while printing operation - query
func (client Client) Request(params *RequestWhereUniqueInput) *RequestExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "RequestWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "request",
		Field: GraphQLField{
			Name:       "request",
			TypeName:   "Request",
			TypeFields: []string{"id", "createdAt", "location", "title", "description"},
		},
		Operation: "query",
		Args:      args,
	})

	return &RequestExec{
		client: client,
		stack:  stack,
	}
}

// RequestsParams docs
type RequestsParams struct {
	Where   *RequestWhereInput   `json:"where,omitempty"`
	OrderBy *RequestOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Requests docs - generated while printing operation - query
func (client Client) Requests(params *RequestsParams) *RequestExecArray {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "RequestWhereInput",
			Value:    *params.Where,
		})
	}
	if params != nil && params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "RequestOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params != nil && params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params != nil && params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params != nil && params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params != nil && params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params != nil && params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "requests",
		Field: GraphQLField{
			Name:       "requests",
			TypeName:   "Request",
			TypeFields: []string{"id", "createdAt", "location", "title", "description"},
		},
		Operation: "query",
		Args:      args,
	})

	return &RequestExecArray{
		client: client,
		stack:  stack,
	}
}

// Exists

// RequestsConnection exists docs
func (exists *Exists) RequestsConnection(params *RequestWhereInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "`http://localhost:4466`"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.RequestsConnection(
		&RequestsConnectionParams{
			Where: params,
		},
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// RequestsConnectionParams docs
type RequestsConnectionParams struct {
	Where   *RequestWhereInput   `json:"where,omitempty"`
	OrderBy *RequestOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// RequestsConnection docs - generated while printing operation - query
func (client Client) RequestsConnection(params *RequestsConnectionParams) *RequestConnectionExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "RequestWhereInput",
			Value:    *params.Where,
		})
	}
	if params != nil && params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "RequestOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params != nil && params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params != nil && params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params != nil && params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params != nil && params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params != nil && params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "requestsConnection",
		Field: GraphQLField{
			Name:       "requestsConnection",
			TypeName:   "RequestConnection",
			TypeFields: []string{},
		},
		Operation: "query",
		Args:      args,
	})

	return &RequestConnectionExec{
		client: client,
		stack:  stack,
	}
}

// Exists

// User exists docs
func (exists *Exists) User(params *UserWhereUniqueInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "`http://localhost:4466`"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.User(
		params,
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// UserParams docs
type UserParams struct {
	Where *UserWhereUniqueInput `json:"where"`
}

// User docs - generated while printing operation - query
func (client Client) User(params *UserWhereUniqueInput) *UserExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "user",
		Field: GraphQLField{
			Name:       "user",
			TypeName:   "User",
			TypeFields: []string{"id", "createdAt", "updatedAt", "name", "email", "password", "profilePicture", "homeLocation", "bio", "isVerified", "showNotifications"},
		},
		Operation: "query",
		Args:      args,
	})

	return &UserExec{
		client: client,
		stack:  stack,
	}
}

// UsersParams docs
type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Users docs - generated while printing operation - query
func (client Client) Users(params *UsersParams) *UserExecArray {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereInput",
			Value:    *params.Where,
		})
	}
	if params != nil && params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "UserOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params != nil && params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params != nil && params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params != nil && params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params != nil && params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params != nil && params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "users",
		Field: GraphQLField{
			Name:       "users",
			TypeName:   "User",
			TypeFields: []string{"id", "createdAt", "updatedAt", "name", "email", "password", "profilePicture", "homeLocation", "bio", "isVerified", "showNotifications"},
		},
		Operation: "query",
		Args:      args,
	})

	return &UserExecArray{
		client: client,
		stack:  stack,
	}
}

// Exists

// UsersConnection exists docs
func (exists *Exists) UsersConnection(params *UserWhereInput) bool {
	client := Client{
		Endpoint: (map[bool]string{true: exists.Endpoint, false: "`http://localhost:4466`"})[exists.Endpoint != ""],
		Debug:    exists.Debug,
	}
	data, err := client.UsersConnection(
		&UsersConnectionParams{
			Where: params,
		},
	).Exec()
	if err != nil {
		if client.Debug {
			fmt.Println("Error Exists", err)
		}
		return false
	}
	if isZeroOfUnderlyingType(data) {
		return false
	}
	return true
}

// UsersConnectionParams docs
type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// UsersConnection docs - generated while printing operation - query
func (client Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereInput",
			Value:    *params.Where,
		})
	}
	if params != nil && params.OrderBy != nil {
		args = append(args, GraphQLArg{
			Name:     "orderBy",
			Key:      "orderBy",
			TypeName: "UserOrderByInput",
			Value:    *params.OrderBy,
		})
	}
	if params != nil && params.Skip != nil {
		args = append(args, GraphQLArg{
			Name:     "skip",
			Key:      "skip",
			TypeName: "Int",
			Value:    *params.Skip,
		})
	}
	if params != nil && params.After != nil {
		args = append(args, GraphQLArg{
			Name:     "after",
			Key:      "after",
			TypeName: "String",
			Value:    *params.After,
		})
	}
	if params != nil && params.Before != nil {
		args = append(args, GraphQLArg{
			Name:     "before",
			Key:      "before",
			TypeName: "String",
			Value:    *params.Before,
		})
	}
	if params != nil && params.First != nil {
		args = append(args, GraphQLArg{
			Name:     "first",
			Key:      "first",
			TypeName: "Int",
			Value:    *params.First,
		})
	}
	if params != nil && params.Last != nil {
		args = append(args, GraphQLArg{
			Name:     "last",
			Key:      "last",
			TypeName: "Int",
			Value:    *params.Last,
		})
	}

	stack = append(stack, Instruction{
		Name: "usersConnection",
		Field: GraphQLField{
			Name:       "usersConnection",
			TypeName:   "UserConnection",
			TypeFields: []string{},
		},
		Operation: "query",
		Args:      args,
	})

	return &UserConnectionExec{
		client: client,
		stack:  stack,
	}
}

// NodeParams docs
type NodeParams struct {
	ID *string `json:"id"`
}

// Node docs - generated while printing operation - query
func (client Client) Node(params *ID) *NodeExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "id",
			Key:      "id",
			TypeName: "ID!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Node",
			TypeFields: []string{},
		},
		Operation: "query",
		Args:      args,
	})

	return &NodeExec{
		client: client,
		stack:  stack,
	}
}

// Mutations

// CreateCommentParams docs
type CreateCommentParams struct {
	Data *CommentCreateInput `json:"data"`
}

// CreateComment docs - generated while printing operation - mutation
func (client Client) CreateComment(params *CommentCreateInput) *CommentExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "CommentCreateInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "createComment",
		Field: GraphQLField{
			Name:       "createComment",
			TypeName:   "Comment",
			TypeFields: []string{"id", "createdAt", "text"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &CommentExec{
		client: client,
		stack:  stack,
	}
}

// UpdateCommentParams docs
type UpdateCommentParams struct {
	Data  *CommentUpdateInput      `json:"data"`
	Where *CommentWhereUniqueInput `json:"where"`
}

// UpdateComment docs - generated while printing operation - mutation
func (client Client) UpdateComment(params *UpdateCommentParams) *CommentExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "CommentUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CommentWhereUniqueInput!",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateComment",
		Field: GraphQLField{
			Name:       "updateComment",
			TypeName:   "Comment",
			TypeFields: []string{"id", "createdAt", "text"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &CommentExec{
		client: client,
		stack:  stack,
	}
}

// UpdateManyCommentsParams docs
type UpdateManyCommentsParams struct {
	Data  *CommentUpdateInput `json:"data"`
	Where *CommentWhereInput  `json:"where,omitempty"`
}

// UpdateManyComments docs - generated while printing operation - mutation
func (client Client) UpdateManyComments(params *UpdateManyCommentsParams) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "CommentUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CommentWhereInput",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateManyComments",
		Field: GraphQLField{
			Name:       "updateManyComments",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// UpsertCommentParams docs
type UpsertCommentParams struct {
	Where  *CommentWhereUniqueInput `json:"where"`
	Create *CommentCreateInput      `json:"create"`
	Update *CommentUpdateInput      `json:"update"`
}

// UpsertComment docs - generated while printing operation - mutation
func (client Client) UpsertComment(params *UpsertCommentParams) *CommentExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CommentWhereUniqueInput!",
			Value:    *params.Where,
		})
	}
	if params != nil && params.Create != nil {
		args = append(args, GraphQLArg{
			Name:     "create",
			Key:      "create",
			TypeName: "CommentCreateInput!",
			Value:    *params.Create,
		})
	}
	if params != nil && params.Update != nil {
		args = append(args, GraphQLArg{
			Name:     "update",
			Key:      "update",
			TypeName: "CommentUpdateInput!",
			Value:    *params.Update,
		})
	}

	stack = append(stack, Instruction{
		Name: "upsertComment",
		Field: GraphQLField{
			Name:       "upsertComment",
			TypeName:   "Comment",
			TypeFields: []string{"id", "createdAt", "text"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &CommentExec{
		client: client,
		stack:  stack,
	}
}

// DeleteCommentParams docs
type DeleteCommentParams struct {
	Where *CommentWhereUniqueInput `json:"where"`
}

// DeleteComment docs - generated while printing operation - mutation
func (client Client) DeleteComment(params *CommentWhereUniqueInput) *CommentExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CommentWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteComment",
		Field: GraphQLField{
			Name:       "deleteComment",
			TypeName:   "Comment",
			TypeFields: []string{"id", "createdAt", "text"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &CommentExec{
		client: client,
		stack:  stack,
	}
}

// DeleteManyCommentsParams docs
type DeleteManyCommentsParams struct {
	Where *CommentWhereInput `json:"where,omitempty"`
}

// DeleteManyComments docs - generated while printing operation - mutation
func (client Client) DeleteManyComments(params *CommentWhereInput) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "CommentWhereInput",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteManyComments",
		Field: GraphQLField{
			Name:       "deleteManyComments",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// CreateRequestParams docs
type CreateRequestParams struct {
	Data *RequestCreateInput `json:"data"`
}

// CreateRequest docs - generated while printing operation - mutation
func (client Client) CreateRequest(params *RequestCreateInput) *RequestExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "RequestCreateInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "createRequest",
		Field: GraphQLField{
			Name:       "createRequest",
			TypeName:   "Request",
			TypeFields: []string{"id", "createdAt", "location", "title", "description"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &RequestExec{
		client: client,
		stack:  stack,
	}
}

// UpdateRequestParams docs
type UpdateRequestParams struct {
	Data  *RequestUpdateInput      `json:"data"`
	Where *RequestWhereUniqueInput `json:"where"`
}

// UpdateRequest docs - generated while printing operation - mutation
func (client Client) UpdateRequest(params *UpdateRequestParams) *RequestExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "RequestUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "RequestWhereUniqueInput!",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateRequest",
		Field: GraphQLField{
			Name:       "updateRequest",
			TypeName:   "Request",
			TypeFields: []string{"id", "createdAt", "location", "title", "description"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &RequestExec{
		client: client,
		stack:  stack,
	}
}

// UpdateManyRequestsParams docs
type UpdateManyRequestsParams struct {
	Data  *RequestUpdateInput `json:"data"`
	Where *RequestWhereInput  `json:"where,omitempty"`
}

// UpdateManyRequests docs - generated while printing operation - mutation
func (client Client) UpdateManyRequests(params *UpdateManyRequestsParams) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "RequestUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "RequestWhereInput",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateManyRequests",
		Field: GraphQLField{
			Name:       "updateManyRequests",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// UpsertRequestParams docs
type UpsertRequestParams struct {
	Where  *RequestWhereUniqueInput `json:"where"`
	Create *RequestCreateInput      `json:"create"`
	Update *RequestUpdateInput      `json:"update"`
}

// UpsertRequest docs - generated while printing operation - mutation
func (client Client) UpsertRequest(params *UpsertRequestParams) *RequestExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "RequestWhereUniqueInput!",
			Value:    *params.Where,
		})
	}
	if params != nil && params.Create != nil {
		args = append(args, GraphQLArg{
			Name:     "create",
			Key:      "create",
			TypeName: "RequestCreateInput!",
			Value:    *params.Create,
		})
	}
	if params != nil && params.Update != nil {
		args = append(args, GraphQLArg{
			Name:     "update",
			Key:      "update",
			TypeName: "RequestUpdateInput!",
			Value:    *params.Update,
		})
	}

	stack = append(stack, Instruction{
		Name: "upsertRequest",
		Field: GraphQLField{
			Name:       "upsertRequest",
			TypeName:   "Request",
			TypeFields: []string{"id", "createdAt", "location", "title", "description"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &RequestExec{
		client: client,
		stack:  stack,
	}
}

// DeleteRequestParams docs
type DeleteRequestParams struct {
	Where *RequestWhereUniqueInput `json:"where"`
}

// DeleteRequest docs - generated while printing operation - mutation
func (client Client) DeleteRequest(params *RequestWhereUniqueInput) *RequestExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "RequestWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteRequest",
		Field: GraphQLField{
			Name:       "deleteRequest",
			TypeName:   "Request",
			TypeFields: []string{"id", "createdAt", "location", "title", "description"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &RequestExec{
		client: client,
		stack:  stack,
	}
}

// DeleteManyRequestsParams docs
type DeleteManyRequestsParams struct {
	Where *RequestWhereInput `json:"where,omitempty"`
}

// DeleteManyRequests docs - generated while printing operation - mutation
func (client Client) DeleteManyRequests(params *RequestWhereInput) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "RequestWhereInput",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteManyRequests",
		Field: GraphQLField{
			Name:       "deleteManyRequests",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// CreateUserParams docs
type CreateUserParams struct {
	Data *UserCreateInput `json:"data"`
}

// CreateUser docs - generated while printing operation - mutation
func (client Client) CreateUser(params *UserCreateInput) *UserExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "UserCreateInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "createUser",
		Field: GraphQLField{
			Name:       "createUser",
			TypeName:   "User",
			TypeFields: []string{"id", "createdAt", "updatedAt", "name", "email", "password", "profilePicture", "homeLocation", "bio", "isVerified", "showNotifications"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &UserExec{
		client: client,
		stack:  stack,
	}
}

// UpdateUserParams docs
type UpdateUserParams struct {
	Data  *UserUpdateInput      `json:"data"`
	Where *UserWhereUniqueInput `json:"where"`
}

// UpdateUser docs - generated while printing operation - mutation
func (client Client) UpdateUser(params *UpdateUserParams) *UserExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "UserUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereUniqueInput!",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateUser",
		Field: GraphQLField{
			Name:       "updateUser",
			TypeName:   "User",
			TypeFields: []string{"id", "createdAt", "updatedAt", "name", "email", "password", "profilePicture", "homeLocation", "bio", "isVerified", "showNotifications"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &UserExec{
		client: client,
		stack:  stack,
	}
}

// UpdateManyUsersParams docs
type UpdateManyUsersParams struct {
	Data  *UserUpdateInput `json:"data"`
	Where *UserWhereInput  `json:"where,omitempty"`
}

// UpdateManyUsers docs - generated while printing operation - mutation
func (client Client) UpdateManyUsers(params *UpdateManyUsersParams) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Data != nil {
		args = append(args, GraphQLArg{
			Name:     "data",
			Key:      "data",
			TypeName: "UserUpdateInput!",
			Value:    *params.Data,
		})
	}
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereInput",
			Value:    *params.Where,
		})
	}

	stack = append(stack, Instruction{
		Name: "updateManyUsers",
		Field: GraphQLField{
			Name:       "updateManyUsers",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// UpsertUserParams docs
type UpsertUserParams struct {
	Where  *UserWhereUniqueInput `json:"where"`
	Create *UserCreateInput      `json:"create"`
	Update *UserUpdateInput      `json:"update"`
}

// UpsertUser docs - generated while printing operation - mutation
func (client Client) UpsertUser(params *UpsertUserParams) *UserExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil && params.Where != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereUniqueInput!",
			Value:    *params.Where,
		})
	}
	if params != nil && params.Create != nil {
		args = append(args, GraphQLArg{
			Name:     "create",
			Key:      "create",
			TypeName: "UserCreateInput!",
			Value:    *params.Create,
		})
	}
	if params != nil && params.Update != nil {
		args = append(args, GraphQLArg{
			Name:     "update",
			Key:      "update",
			TypeName: "UserUpdateInput!",
			Value:    *params.Update,
		})
	}

	stack = append(stack, Instruction{
		Name: "upsertUser",
		Field: GraphQLField{
			Name:       "upsertUser",
			TypeName:   "User",
			TypeFields: []string{"id", "createdAt", "updatedAt", "name", "email", "password", "profilePicture", "homeLocation", "bio", "isVerified", "showNotifications"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &UserExec{
		client: client,
		stack:  stack,
	}
}

// DeleteUserParams docs
type DeleteUserParams struct {
	Where *UserWhereUniqueInput `json:"where"`
}

// DeleteUser docs - generated while printing operation - mutation
func (client Client) DeleteUser(params *UserWhereUniqueInput) *UserExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereUniqueInput!",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteUser",
		Field: GraphQLField{
			Name:       "deleteUser",
			TypeName:   "User",
			TypeFields: []string{"id", "createdAt", "updatedAt", "name", "email", "password", "profilePicture", "homeLocation", "bio", "isVerified", "showNotifications"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &UserExec{
		client: client,
		stack:  stack,
	}
}

// DeleteManyUsersParams docs
type DeleteManyUsersParams struct {
	Where *UserWhereInput `json:"where,omitempty"`
}

// DeleteManyUsers docs - generated while printing operation - mutation
func (client Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {

	stack := make([]Instruction, 0)
	var args []GraphQLArg
	if params != nil {
		args = append(args, GraphQLArg{
			Name:     "where",
			Key:      "where",
			TypeName: "UserWhereInput",
			Value:    *params,
		})
	}

	stack = append(stack, Instruction{
		Name: "deleteManyUsers",
		Field: GraphQLField{
			Name:       "deleteManyUsers",
			TypeName:   "BatchPayload",
			TypeFields: []string{"count"},
		},
		Operation: "mutation",
		Args:      args,
	})

	return &BatchPayloadExec{
		client: client,
		stack:  stack,
	}
}

// Types

// Status docs
type Status string

const (

	// OpenStatus docs
	OpenStatus Status = "OPEN"

	// OrganisingStatus docs
	OrganisingStatus Status = "ORGANISING"

	// OrganisedStatus docs
	OrganisedStatus Status = "ORGANISED"

	// ClosedStatus docs
	ClosedStatus Status = "CLOSED"
)

// Price docs
type Price string

const (

	// FreePrice docs
	FreePrice Price = "FREE"

	// LowPrice docs
	LowPrice Price = "LOW"

	// MediumPrice docs
	MediumPrice Price = "MEDIUM"

	// HighPrice docs
	HighPrice Price = "HIGH"
)

// RequestOrderByInput docs
type RequestOrderByInput string

const (

	// IDAscRequestOrderByInput docs
	IDAscRequestOrderByInput RequestOrderByInput = "id_ASC"

	// IDDescRequestOrderByInput docs
	IDDescRequestOrderByInput RequestOrderByInput = "id_DESC"

	// CreatedAtAscRequestOrderByInput docs
	CreatedAtAscRequestOrderByInput RequestOrderByInput = "createdAt_ASC"

	// CreatedAtDescRequestOrderByInput docs
	CreatedAtDescRequestOrderByInput RequestOrderByInput = "createdAt_DESC"

	// LocationAscRequestOrderByInput docs
	LocationAscRequestOrderByInput RequestOrderByInput = "location_ASC"

	// LocationDescRequestOrderByInput docs
	LocationDescRequestOrderByInput RequestOrderByInput = "location_DESC"

	// TitleAscRequestOrderByInput docs
	TitleAscRequestOrderByInput RequestOrderByInput = "title_ASC"

	// TitleDescRequestOrderByInput docs
	TitleDescRequestOrderByInput RequestOrderByInput = "title_DESC"

	// DescriptionAscRequestOrderByInput docs
	DescriptionAscRequestOrderByInput RequestOrderByInput = "description_ASC"

	// DescriptionDescRequestOrderByInput docs
	DescriptionDescRequestOrderByInput RequestOrderByInput = "description_DESC"

	// StatusAscRequestOrderByInput docs
	StatusAscRequestOrderByInput RequestOrderByInput = "status_ASC"

	// StatusDescRequestOrderByInput docs
	StatusDescRequestOrderByInput RequestOrderByInput = "status_DESC"

	// SuggestedPriceAscRequestOrderByInput docs
	SuggestedPriceAscRequestOrderByInput RequestOrderByInput = "suggestedPrice_ASC"

	// SuggestedPriceDescRequestOrderByInput docs
	SuggestedPriceDescRequestOrderByInput RequestOrderByInput = "suggestedPrice_DESC"

	// UpdatedAtAscRequestOrderByInput docs
	UpdatedAtAscRequestOrderByInput RequestOrderByInput = "updatedAt_ASC"

	// UpdatedAtDescRequestOrderByInput docs
	UpdatedAtDescRequestOrderByInput RequestOrderByInput = "updatedAt_DESC"
)

// UserOrderByInput docs
type UserOrderByInput string

const (

	// IDAscUserOrderByInput docs
	IDAscUserOrderByInput UserOrderByInput = "id_ASC"

	// IDDescUserOrderByInput docs
	IDDescUserOrderByInput UserOrderByInput = "id_DESC"

	// CreatedAtAscUserOrderByInput docs
	CreatedAtAscUserOrderByInput UserOrderByInput = "createdAt_ASC"

	// CreatedAtDescUserOrderByInput docs
	CreatedAtDescUserOrderByInput UserOrderByInput = "createdAt_DESC"

	// UpdatedAtAscUserOrderByInput docs
	UpdatedAtAscUserOrderByInput UserOrderByInput = "updatedAt_ASC"

	// UpdatedAtDescUserOrderByInput docs
	UpdatedAtDescUserOrderByInput UserOrderByInput = "updatedAt_DESC"

	// NameAscUserOrderByInput docs
	NameAscUserOrderByInput UserOrderByInput = "name_ASC"

	// NameDescUserOrderByInput docs
	NameDescUserOrderByInput UserOrderByInput = "name_DESC"

	// EmailAscUserOrderByInput docs
	EmailAscUserOrderByInput UserOrderByInput = "email_ASC"

	// EmailDescUserOrderByInput docs
	EmailDescUserOrderByInput UserOrderByInput = "email_DESC"

	// PasswordAscUserOrderByInput docs
	PasswordAscUserOrderByInput UserOrderByInput = "password_ASC"

	// PasswordDescUserOrderByInput docs
	PasswordDescUserOrderByInput UserOrderByInput = "password_DESC"

	// ProfilePictureAscUserOrderByInput docs
	ProfilePictureAscUserOrderByInput UserOrderByInput = "profilePicture_ASC"

	// ProfilePictureDescUserOrderByInput docs
	ProfilePictureDescUserOrderByInput UserOrderByInput = "profilePicture_DESC"

	// HomeLocationAscUserOrderByInput docs
	HomeLocationAscUserOrderByInput UserOrderByInput = "homeLocation_ASC"

	// HomeLocationDescUserOrderByInput docs
	HomeLocationDescUserOrderByInput UserOrderByInput = "homeLocation_DESC"

	// BioAscUserOrderByInput docs
	BioAscUserOrderByInput UserOrderByInput = "bio_ASC"

	// BioDescUserOrderByInput docs
	BioDescUserOrderByInput UserOrderByInput = "bio_DESC"

	// IsVerifiedAscUserOrderByInput docs
	IsVerifiedAscUserOrderByInput UserOrderByInput = "isVerified_ASC"

	// IsVerifiedDescUserOrderByInput docs
	IsVerifiedDescUserOrderByInput UserOrderByInput = "isVerified_DESC"

	// ShowNotificationsAscUserOrderByInput docs
	ShowNotificationsAscUserOrderByInput UserOrderByInput = "showNotifications_ASC"

	// ShowNotificationsDescUserOrderByInput docs
	ShowNotificationsDescUserOrderByInput UserOrderByInput = "showNotifications_DESC"
)

// CommentOrderByInput docs
type CommentOrderByInput string

const (

	// IDAscCommentOrderByInput docs
	IDAscCommentOrderByInput CommentOrderByInput = "id_ASC"

	// IDDescCommentOrderByInput docs
	IDDescCommentOrderByInput CommentOrderByInput = "id_DESC"

	// CreatedAtAscCommentOrderByInput docs
	CreatedAtAscCommentOrderByInput CommentOrderByInput = "createdAt_ASC"

	// CreatedAtDescCommentOrderByInput docs
	CreatedAtDescCommentOrderByInput CommentOrderByInput = "createdAt_DESC"

	// TextAscCommentOrderByInput docs
	TextAscCommentOrderByInput CommentOrderByInput = "text_ASC"

	// TextDescCommentOrderByInput docs
	TextDescCommentOrderByInput CommentOrderByInput = "text_DESC"

	// UpdatedAtAscCommentOrderByInput docs
	UpdatedAtAscCommentOrderByInput CommentOrderByInput = "updatedAt_ASC"

	// UpdatedAtDescCommentOrderByInput docs
	UpdatedAtDescCommentOrderByInput CommentOrderByInput = "updatedAt_DESC"
)

// MutationType docs
type MutationType string

const (

	// CreatedMutationType docs
	CreatedMutationType MutationType = "CREATED"

	// UpdatedMutationType docs
	UpdatedMutationType MutationType = "UPDATED"

	// DeletedMutationType docs
	DeletedMutationType MutationType = "DELETED"
)

// RequestCreateOneWithoutCommentsInput input struct docs
type RequestCreateOneWithoutCommentsInput struct {
	Create  *RequestCreateWithoutCommentsInput `json:"create,omitempty"`
	Connect *RequestWhereUniqueInput           `json:"connect,omitempty"`
}

// CommentWhereUniqueInput input struct docs
type CommentWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

// UserCreateManyWithoutRequestsJoinedInput input struct docs
type UserCreateManyWithoutRequestsJoinedInput struct {
	Create  *UserCreateWithoutRequestsJoinedInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput                 `json:"connect,omitempty"`
}

// RequestUpdateManyWithoutInterestedUsersInput input struct docs
type RequestUpdateManyWithoutInterestedUsersInput struct {
	Create     *RequestCreateWithoutInterestedUsersInput                `json:"create,omitempty"`
	Delete     *RequestWhereUniqueInput                                 `json:"delete,omitempty"`
	Connect    *RequestWhereUniqueInput                                 `json:"connect,omitempty"`
	Disconnect *RequestWhereUniqueInput                                 `json:"disconnect,omitempty"`
	Update     *RequestUpdateWithWhereUniqueWithoutInterestedUsersInput `json:"update,omitempty"`
	Upsert     *RequestUpsertWithWhereUniqueWithoutInterestedUsersInput `json:"upsert,omitempty"`
}

// UserCreateWithoutRequestsJoinedInput input struct docs
type UserCreateWithoutRequestsJoinedInput struct {
	Name              *string                                 `json:"name,omitempty"`
	Email             *string                                 `json:"email,omitempty"`
	Password          *string                                 `json:"password,omitempty"`
	ProfilePicture    *string                                 `json:"profilePicture,omitempty"`
	HomeLocation      *string                                 `json:"homeLocation,omitempty"`
	Bio               *string                                 `json:"bio,omitempty"`
	RequestsMade      *RequestCreateManyWithoutCreatedByInput `json:"requestsMade,omitempty"`
	IsVerified        *bool                                   `json:"isVerified,omitempty"`
	ShowNotifications *bool                                   `json:"showNotifications,omitempty"`
}

// UserUpdateDataInput input struct docs
type UserUpdateDataInput struct {
	Name              *string                                       `json:"name,omitempty"`
	Email             *string                                       `json:"email,omitempty"`
	Password          *string                                       `json:"password,omitempty"`
	ProfilePicture    *string                                       `json:"profilePicture,omitempty"`
	HomeLocation      *string                                       `json:"homeLocation,omitempty"`
	Bio               *string                                       `json:"bio,omitempty"`
	RequestsMade      *RequestUpdateManyWithoutCreatedByInput       `json:"requestsMade,omitempty"`
	RequestsJoined    *RequestUpdateManyWithoutInterestedUsersInput `json:"requestsJoined,omitempty"`
	IsVerified        *bool                                         `json:"isVerified,omitempty"`
	ShowNotifications *bool                                         `json:"showNotifications,omitempty"`
}

// CommentCreateManyWithoutRequestInput input struct docs
type CommentCreateManyWithoutRequestInput struct {
	Create  *CommentCreateWithoutRequestInput `json:"create,omitempty"`
	Connect *CommentWhereUniqueInput          `json:"connect,omitempty"`
}

// RequestWhereInput input struct docs
type RequestWhereInput struct {
	ID                       *string            `json:"id,omitempty"`
	IDNot                    *string            `json:"id_not,omitempty"`
	IDIn                     *string            `json:"id_in,omitempty"`
	IDNotIn                  *string            `json:"id_not_in,omitempty"`
	IDLt                     *string            `json:"id_lt,omitempty"`
	IDLte                    *string            `json:"id_lte,omitempty"`
	IDGt                     *string            `json:"id_gt,omitempty"`
	IDGte                    *string            `json:"id_gte,omitempty"`
	IDContains               *string            `json:"id_contains,omitempty"`
	IDNotContains            *string            `json:"id_not_contains,omitempty"`
	IDStartsWith             *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string            `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string            `json:"createdAt,omitempty"`
	CreatedAtNot             *string            `json:"createdAt_not,omitempty"`
	CreatedAtIn              *string            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           *string            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string            `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string            `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string            `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string            `json:"createdAt_gte,omitempty"`
	CreatedBy                *UserWhereInput    `json:"createdBy,omitempty"`
	Location                 *string            `json:"location,omitempty"`
	LocationNot              *string            `json:"location_not,omitempty"`
	LocationIn               *string            `json:"location_in,omitempty"`
	LocationNotIn            *string            `json:"location_not_in,omitempty"`
	LocationLt               *string            `json:"location_lt,omitempty"`
	LocationLte              *string            `json:"location_lte,omitempty"`
	LocationGt               *string            `json:"location_gt,omitempty"`
	LocationGte              *string            `json:"location_gte,omitempty"`
	LocationContains         *string            `json:"location_contains,omitempty"`
	LocationNotContains      *string            `json:"location_not_contains,omitempty"`
	LocationStartsWith       *string            `json:"location_starts_with,omitempty"`
	LocationNotStartsWith    *string            `json:"location_not_starts_with,omitempty"`
	LocationEndsWith         *string            `json:"location_ends_with,omitempty"`
	LocationNotEndsWith      *string            `json:"location_not_ends_with,omitempty"`
	Title                    *string            `json:"title,omitempty"`
	TitleNot                 *string            `json:"title_not,omitempty"`
	TitleIn                  *string            `json:"title_in,omitempty"`
	TitleNotIn               *string            `json:"title_not_in,omitempty"`
	TitleLt                  *string            `json:"title_lt,omitempty"`
	TitleLte                 *string            `json:"title_lte,omitempty"`
	TitleGt                  *string            `json:"title_gt,omitempty"`
	TitleGte                 *string            `json:"title_gte,omitempty"`
	TitleContains            *string            `json:"title_contains,omitempty"`
	TitleNotContains         *string            `json:"title_not_contains,omitempty"`
	TitleStartsWith          *string            `json:"title_starts_with,omitempty"`
	TitleNotStartsWith       *string            `json:"title_not_starts_with,omitempty"`
	TitleEndsWith            *string            `json:"title_ends_with,omitempty"`
	TitleNotEndsWith         *string            `json:"title_not_ends_with,omitempty"`
	Description              *string            `json:"description,omitempty"`
	DescriptionNot           *string            `json:"description_not,omitempty"`
	DescriptionIn            *string            `json:"description_in,omitempty"`
	DescriptionNotIn         *string            `json:"description_not_in,omitempty"`
	DescriptionLt            *string            `json:"description_lt,omitempty"`
	DescriptionLte           *string            `json:"description_lte,omitempty"`
	DescriptionGt            *string            `json:"description_gt,omitempty"`
	DescriptionGte           *string            `json:"description_gte,omitempty"`
	DescriptionContains      *string            `json:"description_contains,omitempty"`
	DescriptionNotContains   *string            `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string            `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string            `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string            `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string            `json:"description_not_ends_with,omitempty"`
	Status                   *Status            `json:"status,omitempty"`
	StatusNot                *Status            `json:"status_not,omitempty"`
	StatusIn                 *Status            `json:"status_in,omitempty"`
	StatusNotIn              *Status            `json:"status_not_in,omitempty"`
	InterestedUsersEvery     *UserWhereInput    `json:"interestedUsers_every,omitempty"`
	InterestedUsersSome      *UserWhereInput    `json:"interestedUsers_some,omitempty"`
	InterestedUsersNone      *UserWhereInput    `json:"interestedUsers_none,omitempty"`
	CommentsEvery            *CommentWhereInput `json:"comments_every,omitempty"`
	CommentsSome             *CommentWhereInput `json:"comments_some,omitempty"`
	CommentsNone             *CommentWhereInput `json:"comments_none,omitempty"`
	SuggestedPrice           *Price             `json:"suggestedPrice,omitempty"`
	SuggestedPriceNot        *Price             `json:"suggestedPrice_not,omitempty"`
	SuggestedPriceIn         *Price             `json:"suggestedPrice_in,omitempty"`
	SuggestedPriceNotIn      *Price             `json:"suggestedPrice_not_in,omitempty"`
	And                      *RequestWhereInput `json:"AND,omitempty"`
	Or                       *RequestWhereInput `json:"OR,omitempty"`
	Not                      *RequestWhereInput `json:"NOT,omitempty"`
}

// CommentCreateWithoutRequestInput input struct docs
type CommentCreateWithoutRequestInput struct {
	CreatedBy *UserCreateOneInput `json:"createdBy,omitempty"`
	Text      *string             `json:"text,omitempty"`
}

// RequestSubscriptionWhereInput input struct docs
type RequestSubscriptionWhereInput struct {
	MutationIn                 *MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery *string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  *string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *RequestWhereInput             `json:"node,omitempty"`
	And                        *RequestSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         *RequestSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        *RequestSubscriptionWhereInput `json:"NOT,omitempty"`
}

// RequestCreateManyWithoutInterestedUsersInput input struct docs
type RequestCreateManyWithoutInterestedUsersInput struct {
	Create  *RequestCreateWithoutInterestedUsersInput `json:"create,omitempty"`
	Connect *RequestWhereUniqueInput                  `json:"connect,omitempty"`
}

// UserUpdateInput input struct docs
type UserUpdateInput struct {
	Name              *string                                       `json:"name,omitempty"`
	Email             *string                                       `json:"email,omitempty"`
	Password          *string                                       `json:"password,omitempty"`
	ProfilePicture    *string                                       `json:"profilePicture,omitempty"`
	HomeLocation      *string                                       `json:"homeLocation,omitempty"`
	Bio               *string                                       `json:"bio,omitempty"`
	RequestsMade      *RequestUpdateManyWithoutCreatedByInput       `json:"requestsMade,omitempty"`
	RequestsJoined    *RequestUpdateManyWithoutInterestedUsersInput `json:"requestsJoined,omitempty"`
	IsVerified        *bool                                         `json:"isVerified,omitempty"`
	ShowNotifications *bool                                         `json:"showNotifications,omitempty"`
}

// RequestCreateWithoutInterestedUsersInput input struct docs
type RequestCreateWithoutInterestedUsersInput struct {
	CreatedBy      *UserCreateOneWithoutRequestsMadeInput `json:"createdBy,omitempty"`
	Location       *string                                `json:"location,omitempty"`
	Title          *string                                `json:"title,omitempty"`
	Description    *string                                `json:"description,omitempty"`
	Status         *Status                                `json:"status,omitempty"`
	Comments       *CommentCreateManyWithoutRequestInput  `json:"comments,omitempty"`
	SuggestedPrice *Price                                 `json:"suggestedPrice,omitempty"`
}

// RequestCreateInput input struct docs
type RequestCreateInput struct {
	CreatedBy       *UserCreateOneWithoutRequestsMadeInput    `json:"createdBy,omitempty"`
	Location        *string                                   `json:"location,omitempty"`
	Title           *string                                   `json:"title,omitempty"`
	Description     *string                                   `json:"description,omitempty"`
	Status          *Status                                   `json:"status,omitempty"`
	InterestedUsers *UserCreateManyWithoutRequestsJoinedInput `json:"interestedUsers,omitempty"`
	Comments        *CommentCreateManyWithoutRequestInput     `json:"comments,omitempty"`
	SuggestedPrice  *Price                                    `json:"suggestedPrice,omitempty"`
}

// UserCreateOneWithoutRequestsMadeInput input struct docs
type UserCreateOneWithoutRequestsMadeInput struct {
	Create  *UserCreateWithoutRequestsMadeInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput               `json:"connect,omitempty"`
}

// RequestUpdateWithoutCommentsDataInput input struct docs
type RequestUpdateWithoutCommentsDataInput struct {
	CreatedBy       *UserUpdateOneRequiredWithoutRequestsMadeInput `json:"createdBy,omitempty"`
	Location        *string                                        `json:"location,omitempty"`
	Title           *string                                        `json:"title,omitempty"`
	Description     *string                                        `json:"description,omitempty"`
	Status          *Status                                        `json:"status,omitempty"`
	InterestedUsers *UserUpdateManyWithoutRequestsJoinedInput      `json:"interestedUsers,omitempty"`
	SuggestedPrice  *Price                                         `json:"suggestedPrice,omitempty"`
}

// UserCreateWithoutRequestsMadeInput input struct docs
type UserCreateWithoutRequestsMadeInput struct {
	Name              *string                                       `json:"name,omitempty"`
	Email             *string                                       `json:"email,omitempty"`
	Password          *string                                       `json:"password,omitempty"`
	ProfilePicture    *string                                       `json:"profilePicture,omitempty"`
	HomeLocation      *string                                       `json:"homeLocation,omitempty"`
	Bio               *string                                       `json:"bio,omitempty"`
	RequestsJoined    *RequestCreateManyWithoutInterestedUsersInput `json:"requestsJoined,omitempty"`
	IsVerified        *bool                                         `json:"isVerified,omitempty"`
	ShowNotifications *bool                                         `json:"showNotifications,omitempty"`
}

// RequestWhereUniqueInput input struct docs
type RequestWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

// RequestUpdateWithWhereUniqueWithoutInterestedUsersInput input struct docs
type RequestUpdateWithWhereUniqueWithoutInterestedUsersInput struct {
	Where *RequestWhereUniqueInput                      `json:"where,omitempty"`
	Data  *RequestUpdateWithoutInterestedUsersDataInput `json:"data,omitempty"`
}

// RequestUpsertWithWhereUniqueWithoutInterestedUsersInput input struct docs
type RequestUpsertWithWhereUniqueWithoutInterestedUsersInput struct {
	Where  *RequestWhereUniqueInput                      `json:"where,omitempty"`
	Update *RequestUpdateWithoutInterestedUsersDataInput `json:"update,omitempty"`
	Create *RequestCreateWithoutInterestedUsersInput     `json:"create,omitempty"`
}

// RequestCreateWithoutCommentsInput input struct docs
type RequestCreateWithoutCommentsInput struct {
	CreatedBy       *UserCreateOneWithoutRequestsMadeInput    `json:"createdBy,omitempty"`
	Location        *string                                   `json:"location,omitempty"`
	Title           *string                                   `json:"title,omitempty"`
	Description     *string                                   `json:"description,omitempty"`
	Status          *Status                                   `json:"status,omitempty"`
	InterestedUsers *UserCreateManyWithoutRequestsJoinedInput `json:"interestedUsers,omitempty"`
	SuggestedPrice  *Price                                    `json:"suggestedPrice,omitempty"`
}

// UserWhereUniqueInput input struct docs
type UserWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

// CommentUpdateInput input struct docs
type CommentUpdateInput struct {
	CreatedBy *UserUpdateOneRequiredInput                   `json:"createdBy,omitempty"`
	Text      *string                                       `json:"text,omitempty"`
	Request   *RequestUpdateOneRequiredWithoutCommentsInput `json:"request,omitempty"`
}

// UserUpdateOneRequiredWithoutRequestsMadeInput input struct docs
type UserUpdateOneRequiredWithoutRequestsMadeInput struct {
	Create  *UserCreateWithoutRequestsMadeInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutRequestsMadeDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutRequestsMadeInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput                   `json:"connect,omitempty"`
}

// UserUpdateOneRequiredInput input struct docs
type UserUpdateOneRequiredInput struct {
	Create  *UserCreateInput       `json:"create,omitempty"`
	Update  *UserUpdateDataInput   `json:"update,omitempty"`
	Upsert  *UserUpsertNestedInput `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput  `json:"connect,omitempty"`
}

// UserCreateOneInput input struct docs
type UserCreateOneInput struct {
	Create  *UserCreateInput      `json:"create,omitempty"`
	Connect *UserWhereUniqueInput `json:"connect,omitempty"`
}

// UserWhereInput input struct docs
type UserWhereInput struct {
	ID                          *string            `json:"id,omitempty"`
	IDNot                       *string            `json:"id_not,omitempty"`
	IDIn                        *string            `json:"id_in,omitempty"`
	IDNotIn                     *string            `json:"id_not_in,omitempty"`
	IDLt                        *string            `json:"id_lt,omitempty"`
	IDLte                       *string            `json:"id_lte,omitempty"`
	IDGt                        *string            `json:"id_gt,omitempty"`
	IDGte                       *string            `json:"id_gte,omitempty"`
	IDContains                  *string            `json:"id_contains,omitempty"`
	IDNotContains               *string            `json:"id_not_contains,omitempty"`
	IDStartsWith                *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string            `json:"id_not_ends_with,omitempty"`
	CreatedAt                   *string            `json:"createdAt,omitempty"`
	CreatedAtNot                *string            `json:"createdAt_not,omitempty"`
	CreatedAtIn                 *string            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              *string            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string            `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string            `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string            `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string            `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string            `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 *string            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              *string            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string            `json:"updatedAt_gte,omitempty"`
	Name                        *string            `json:"name,omitempty"`
	NameNot                     *string            `json:"name_not,omitempty"`
	NameIn                      *string            `json:"name_in,omitempty"`
	NameNotIn                   *string            `json:"name_not_in,omitempty"`
	NameLt                      *string            `json:"name_lt,omitempty"`
	NameLte                     *string            `json:"name_lte,omitempty"`
	NameGt                      *string            `json:"name_gt,omitempty"`
	NameGte                     *string            `json:"name_gte,omitempty"`
	NameContains                *string            `json:"name_contains,omitempty"`
	NameNotContains             *string            `json:"name_not_contains,omitempty"`
	NameStartsWith              *string            `json:"name_starts_with,omitempty"`
	NameNotStartsWith           *string            `json:"name_not_starts_with,omitempty"`
	NameEndsWith                *string            `json:"name_ends_with,omitempty"`
	NameNotEndsWith             *string            `json:"name_not_ends_with,omitempty"`
	Email                       *string            `json:"email,omitempty"`
	EmailNot                    *string            `json:"email_not,omitempty"`
	EmailIn                     *string            `json:"email_in,omitempty"`
	EmailNotIn                  *string            `json:"email_not_in,omitempty"`
	EmailLt                     *string            `json:"email_lt,omitempty"`
	EmailLte                    *string            `json:"email_lte,omitempty"`
	EmailGt                     *string            `json:"email_gt,omitempty"`
	EmailGte                    *string            `json:"email_gte,omitempty"`
	EmailContains               *string            `json:"email_contains,omitempty"`
	EmailNotContains            *string            `json:"email_not_contains,omitempty"`
	EmailStartsWith             *string            `json:"email_starts_with,omitempty"`
	EmailNotStartsWith          *string            `json:"email_not_starts_with,omitempty"`
	EmailEndsWith               *string            `json:"email_ends_with,omitempty"`
	EmailNotEndsWith            *string            `json:"email_not_ends_with,omitempty"`
	Password                    *string            `json:"password,omitempty"`
	PasswordNot                 *string            `json:"password_not,omitempty"`
	PasswordIn                  *string            `json:"password_in,omitempty"`
	PasswordNotIn               *string            `json:"password_not_in,omitempty"`
	PasswordLt                  *string            `json:"password_lt,omitempty"`
	PasswordLte                 *string            `json:"password_lte,omitempty"`
	PasswordGt                  *string            `json:"password_gt,omitempty"`
	PasswordGte                 *string            `json:"password_gte,omitempty"`
	PasswordContains            *string            `json:"password_contains,omitempty"`
	PasswordNotContains         *string            `json:"password_not_contains,omitempty"`
	PasswordStartsWith          *string            `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith       *string            `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith            *string            `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith         *string            `json:"password_not_ends_with,omitempty"`
	ProfilePicture              *string            `json:"profilePicture,omitempty"`
	ProfilePictureNot           *string            `json:"profilePicture_not,omitempty"`
	ProfilePictureIn            *string            `json:"profilePicture_in,omitempty"`
	ProfilePictureNotIn         *string            `json:"profilePicture_not_in,omitempty"`
	ProfilePictureLt            *string            `json:"profilePicture_lt,omitempty"`
	ProfilePictureLte           *string            `json:"profilePicture_lte,omitempty"`
	ProfilePictureGt            *string            `json:"profilePicture_gt,omitempty"`
	ProfilePictureGte           *string            `json:"profilePicture_gte,omitempty"`
	ProfilePictureContains      *string            `json:"profilePicture_contains,omitempty"`
	ProfilePictureNotContains   *string            `json:"profilePicture_not_contains,omitempty"`
	ProfilePictureStartsWith    *string            `json:"profilePicture_starts_with,omitempty"`
	ProfilePictureNotStartsWith *string            `json:"profilePicture_not_starts_with,omitempty"`
	ProfilePictureEndsWith      *string            `json:"profilePicture_ends_with,omitempty"`
	ProfilePictureNotEndsWith   *string            `json:"profilePicture_not_ends_with,omitempty"`
	HomeLocation                *string            `json:"homeLocation,omitempty"`
	HomeLocationNot             *string            `json:"homeLocation_not,omitempty"`
	HomeLocationIn              *string            `json:"homeLocation_in,omitempty"`
	HomeLocationNotIn           *string            `json:"homeLocation_not_in,omitempty"`
	HomeLocationLt              *string            `json:"homeLocation_lt,omitempty"`
	HomeLocationLte             *string            `json:"homeLocation_lte,omitempty"`
	HomeLocationGt              *string            `json:"homeLocation_gt,omitempty"`
	HomeLocationGte             *string            `json:"homeLocation_gte,omitempty"`
	HomeLocationContains        *string            `json:"homeLocation_contains,omitempty"`
	HomeLocationNotContains     *string            `json:"homeLocation_not_contains,omitempty"`
	HomeLocationStartsWith      *string            `json:"homeLocation_starts_with,omitempty"`
	HomeLocationNotStartsWith   *string            `json:"homeLocation_not_starts_with,omitempty"`
	HomeLocationEndsWith        *string            `json:"homeLocation_ends_with,omitempty"`
	HomeLocationNotEndsWith     *string            `json:"homeLocation_not_ends_with,omitempty"`
	Bio                         *string            `json:"bio,omitempty"`
	BioNot                      *string            `json:"bio_not,omitempty"`
	BioIn                       *string            `json:"bio_in,omitempty"`
	BioNotIn                    *string            `json:"bio_not_in,omitempty"`
	BioLt                       *string            `json:"bio_lt,omitempty"`
	BioLte                      *string            `json:"bio_lte,omitempty"`
	BioGt                       *string            `json:"bio_gt,omitempty"`
	BioGte                      *string            `json:"bio_gte,omitempty"`
	BioContains                 *string            `json:"bio_contains,omitempty"`
	BioNotContains              *string            `json:"bio_not_contains,omitempty"`
	BioStartsWith               *string            `json:"bio_starts_with,omitempty"`
	BioNotStartsWith            *string            `json:"bio_not_starts_with,omitempty"`
	BioEndsWith                 *string            `json:"bio_ends_with,omitempty"`
	BioNotEndsWith              *string            `json:"bio_not_ends_with,omitempty"`
	RequestsMadeEvery           *RequestWhereInput `json:"requestsMade_every,omitempty"`
	RequestsMadeSome            *RequestWhereInput `json:"requestsMade_some,omitempty"`
	RequestsMadeNone            *RequestWhereInput `json:"requestsMade_none,omitempty"`
	RequestsJoinedEvery         *RequestWhereInput `json:"requestsJoined_every,omitempty"`
	RequestsJoinedSome          *RequestWhereInput `json:"requestsJoined_some,omitempty"`
	RequestsJoinedNone          *RequestWhereInput `json:"requestsJoined_none,omitempty"`
	IsVerified                  *bool              `json:"isVerified,omitempty"`
	IsVerifiedNot               *bool              `json:"isVerified_not,omitempty"`
	ShowNotifications           *bool              `json:"showNotifications,omitempty"`
	ShowNotificationsNot        *bool              `json:"showNotifications_not,omitempty"`
	And                         *UserWhereInput    `json:"AND,omitempty"`
	Or                          *UserWhereInput    `json:"OR,omitempty"`
	Not                         *UserWhereInput    `json:"NOT,omitempty"`
}

// RequestCreateManyWithoutCreatedByInput input struct docs
type RequestCreateManyWithoutCreatedByInput struct {
	Create  *RequestCreateWithoutCreatedByInput `json:"create,omitempty"`
	Connect *RequestWhereUniqueInput            `json:"connect,omitempty"`
}

// RequestUpdateManyWithoutCreatedByInput input struct docs
type RequestUpdateManyWithoutCreatedByInput struct {
	Create     *RequestCreateWithoutCreatedByInput                `json:"create,omitempty"`
	Delete     *RequestWhereUniqueInput                           `json:"delete,omitempty"`
	Connect    *RequestWhereUniqueInput                           `json:"connect,omitempty"`
	Disconnect *RequestWhereUniqueInput                           `json:"disconnect,omitempty"`
	Update     *RequestUpdateWithWhereUniqueWithoutCreatedByInput `json:"update,omitempty"`
	Upsert     *RequestUpsertWithWhereUniqueWithoutCreatedByInput `json:"upsert,omitempty"`
}

// CommentWhereInput input struct docs
type CommentWhereInput struct {
	ID                *string            `json:"id,omitempty"`
	IDNot             *string            `json:"id_not,omitempty"`
	IDIn              *string            `json:"id_in,omitempty"`
	IDNotIn           *string            `json:"id_not_in,omitempty"`
	IDLt              *string            `json:"id_lt,omitempty"`
	IDLte             *string            `json:"id_lte,omitempty"`
	IDGt              *string            `json:"id_gt,omitempty"`
	IDGte             *string            `json:"id_gte,omitempty"`
	IDContains        *string            `json:"id_contains,omitempty"`
	IDNotContains     *string            `json:"id_not_contains,omitempty"`
	IDStartsWith      *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string            `json:"id_not_ends_with,omitempty"`
	CreatedAt         *string            `json:"createdAt,omitempty"`
	CreatedAtNot      *string            `json:"createdAt_not,omitempty"`
	CreatedAtIn       *string            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    *string            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string            `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string            `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string            `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string            `json:"createdAt_gte,omitempty"`
	CreatedBy         *UserWhereInput    `json:"createdBy,omitempty"`
	Text              *string            `json:"text,omitempty"`
	TextNot           *string            `json:"text_not,omitempty"`
	TextIn            *string            `json:"text_in,omitempty"`
	TextNotIn         *string            `json:"text_not_in,omitempty"`
	TextLt            *string            `json:"text_lt,omitempty"`
	TextLte           *string            `json:"text_lte,omitempty"`
	TextGt            *string            `json:"text_gt,omitempty"`
	TextGte           *string            `json:"text_gte,omitempty"`
	TextContains      *string            `json:"text_contains,omitempty"`
	TextNotContains   *string            `json:"text_not_contains,omitempty"`
	TextStartsWith    *string            `json:"text_starts_with,omitempty"`
	TextNotStartsWith *string            `json:"text_not_starts_with,omitempty"`
	TextEndsWith      *string            `json:"text_ends_with,omitempty"`
	TextNotEndsWith   *string            `json:"text_not_ends_with,omitempty"`
	Request           *RequestWhereInput `json:"request,omitempty"`
	And               *CommentWhereInput `json:"AND,omitempty"`
	Or                *CommentWhereInput `json:"OR,omitempty"`
	Not               *CommentWhereInput `json:"NOT,omitempty"`
}

// RequestUpdateWithWhereUniqueWithoutCreatedByInput input struct docs
type RequestUpdateWithWhereUniqueWithoutCreatedByInput struct {
	Where *RequestWhereUniqueInput                `json:"where,omitempty"`
	Data  *RequestUpdateWithoutCreatedByDataInput `json:"data,omitempty"`
}

// CommentSubscriptionWhereInput input struct docs
type CommentSubscriptionWhereInput struct {
	MutationIn                 *MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery *string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  *string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *CommentWhereInput             `json:"node,omitempty"`
	And                        *CommentSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         *CommentSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        *CommentSubscriptionWhereInput `json:"NOT,omitempty"`
}

// RequestUpdateWithoutCreatedByDataInput input struct docs
type RequestUpdateWithoutCreatedByDataInput struct {
	Location        *string                                   `json:"location,omitempty"`
	Title           *string                                   `json:"title,omitempty"`
	Description     *string                                   `json:"description,omitempty"`
	Status          *Status                                   `json:"status,omitempty"`
	InterestedUsers *UserUpdateManyWithoutRequestsJoinedInput `json:"interestedUsers,omitempty"`
	Comments        *CommentUpdateManyWithoutRequestInput     `json:"comments,omitempty"`
	SuggestedPrice  *Price                                    `json:"suggestedPrice,omitempty"`
}

// RequestUpsertWithoutCommentsInput input struct docs
type RequestUpsertWithoutCommentsInput struct {
	Update *RequestUpdateWithoutCommentsDataInput `json:"update,omitempty"`
	Create *RequestCreateWithoutCommentsInput     `json:"create,omitempty"`
}

// UserUpdateManyWithoutRequestsJoinedInput input struct docs
type UserUpdateManyWithoutRequestsJoinedInput struct {
	Create     *UserCreateWithoutRequestsJoinedInput                `json:"create,omitempty"`
	Delete     *UserWhereUniqueInput                                `json:"delete,omitempty"`
	Connect    *UserWhereUniqueInput                                `json:"connect,omitempty"`
	Disconnect *UserWhereUniqueInput                                `json:"disconnect,omitempty"`
	Update     *UserUpdateWithWhereUniqueWithoutRequestsJoinedInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithWhereUniqueWithoutRequestsJoinedInput `json:"upsert,omitempty"`
}

// UserUpsertNestedInput input struct docs
type UserUpsertNestedInput struct {
	Update *UserUpdateDataInput `json:"update,omitempty"`
	Create *UserCreateInput     `json:"create,omitempty"`
}

// UserUpdateWithWhereUniqueWithoutRequestsJoinedInput input struct docs
type UserUpdateWithWhereUniqueWithoutRequestsJoinedInput struct {
	Where *UserWhereUniqueInput                     `json:"where,omitempty"`
	Data  *UserUpdateWithoutRequestsJoinedDataInput `json:"data,omitempty"`
}

// UserUpdateWithoutRequestsMadeDataInput input struct docs
type UserUpdateWithoutRequestsMadeDataInput struct {
	Name              *string                                       `json:"name,omitempty"`
	Email             *string                                       `json:"email,omitempty"`
	Password          *string                                       `json:"password,omitempty"`
	ProfilePicture    *string                                       `json:"profilePicture,omitempty"`
	HomeLocation      *string                                       `json:"homeLocation,omitempty"`
	Bio               *string                                       `json:"bio,omitempty"`
	RequestsJoined    *RequestUpdateManyWithoutInterestedUsersInput `json:"requestsJoined,omitempty"`
	IsVerified        *bool                                         `json:"isVerified,omitempty"`
	ShowNotifications *bool                                         `json:"showNotifications,omitempty"`
}

// UserUpdateWithoutRequestsJoinedDataInput input struct docs
type UserUpdateWithoutRequestsJoinedDataInput struct {
	Name              *string                                 `json:"name,omitempty"`
	Email             *string                                 `json:"email,omitempty"`
	Password          *string                                 `json:"password,omitempty"`
	ProfilePicture    *string                                 `json:"profilePicture,omitempty"`
	HomeLocation      *string                                 `json:"homeLocation,omitempty"`
	Bio               *string                                 `json:"bio,omitempty"`
	RequestsMade      *RequestUpdateManyWithoutCreatedByInput `json:"requestsMade,omitempty"`
	IsVerified        *bool                                   `json:"isVerified,omitempty"`
	ShowNotifications *bool                                   `json:"showNotifications,omitempty"`
}

// CommentCreateInput input struct docs
type CommentCreateInput struct {
	CreatedBy *UserCreateOneInput                   `json:"createdBy,omitempty"`
	Text      *string                               `json:"text,omitempty"`
	Request   *RequestCreateOneWithoutCommentsInput `json:"request,omitempty"`
}

// UserUpsertWithWhereUniqueWithoutRequestsJoinedInput input struct docs
type UserUpsertWithWhereUniqueWithoutRequestsJoinedInput struct {
	Where  *UserWhereUniqueInput                     `json:"where,omitempty"`
	Update *UserUpdateWithoutRequestsJoinedDataInput `json:"update,omitempty"`
	Create *UserCreateWithoutRequestsJoinedInput     `json:"create,omitempty"`
}

// RequestCreateWithoutCreatedByInput input struct docs
type RequestCreateWithoutCreatedByInput struct {
	Location        *string                                   `json:"location,omitempty"`
	Title           *string                                   `json:"title,omitempty"`
	Description     *string                                   `json:"description,omitempty"`
	Status          *Status                                   `json:"status,omitempty"`
	InterestedUsers *UserCreateManyWithoutRequestsJoinedInput `json:"interestedUsers,omitempty"`
	Comments        *CommentCreateManyWithoutRequestInput     `json:"comments,omitempty"`
	SuggestedPrice  *Price                                    `json:"suggestedPrice,omitempty"`
}

// CommentUpdateManyWithoutRequestInput input struct docs
type CommentUpdateManyWithoutRequestInput struct {
	Create     *CommentCreateWithoutRequestInput                `json:"create,omitempty"`
	Delete     *CommentWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    *CommentWhereUniqueInput                         `json:"connect,omitempty"`
	Disconnect *CommentWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     *CommentUpdateWithWhereUniqueWithoutRequestInput `json:"update,omitempty"`
	Upsert     *CommentUpsertWithWhereUniqueWithoutRequestInput `json:"upsert,omitempty"`
}

// RequestUpdateInput input struct docs
type RequestUpdateInput struct {
	CreatedBy       *UserUpdateOneRequiredWithoutRequestsMadeInput `json:"createdBy,omitempty"`
	Location        *string                                        `json:"location,omitempty"`
	Title           *string                                        `json:"title,omitempty"`
	Description     *string                                        `json:"description,omitempty"`
	Status          *Status                                        `json:"status,omitempty"`
	InterestedUsers *UserUpdateManyWithoutRequestsJoinedInput      `json:"interestedUsers,omitempty"`
	Comments        *CommentUpdateManyWithoutRequestInput          `json:"comments,omitempty"`
	SuggestedPrice  *Price                                         `json:"suggestedPrice,omitempty"`
}

// RequestUpsertWithWhereUniqueWithoutCreatedByInput input struct docs
type RequestUpsertWithWhereUniqueWithoutCreatedByInput struct {
	Where  *RequestWhereUniqueInput                `json:"where,omitempty"`
	Update *RequestUpdateWithoutCreatedByDataInput `json:"update,omitempty"`
	Create *RequestCreateWithoutCreatedByInput     `json:"create,omitempty"`
}

// CommentUpsertWithWhereUniqueWithoutRequestInput input struct docs
type CommentUpsertWithWhereUniqueWithoutRequestInput struct {
	Where  *CommentWhereUniqueInput              `json:"where,omitempty"`
	Update *CommentUpdateWithoutRequestDataInput `json:"update,omitempty"`
	Create *CommentCreateWithoutRequestInput     `json:"create,omitempty"`
}

// CommentUpdateWithoutRequestDataInput input struct docs
type CommentUpdateWithoutRequestDataInput struct {
	CreatedBy *UserUpdateOneRequiredInput `json:"createdBy,omitempty"`
	Text      *string                     `json:"text,omitempty"`
}

// CommentUpdateWithWhereUniqueWithoutRequestInput input struct docs
type CommentUpdateWithWhereUniqueWithoutRequestInput struct {
	Where *CommentWhereUniqueInput              `json:"where,omitempty"`
	Data  *CommentUpdateWithoutRequestDataInput `json:"data,omitempty"`
}

// RequestUpdateOneRequiredWithoutCommentsInput input struct docs
type RequestUpdateOneRequiredWithoutCommentsInput struct {
	Create  *RequestCreateWithoutCommentsInput     `json:"create,omitempty"`
	Update  *RequestUpdateWithoutCommentsDataInput `json:"update,omitempty"`
	Upsert  *RequestUpsertWithoutCommentsInput     `json:"upsert,omitempty"`
	Connect *RequestWhereUniqueInput               `json:"connect,omitempty"`
}

// UserSubscriptionWhereInput input struct docs
type UserSubscriptionWhereInput struct {
	MutationIn                 *MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery *string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  *string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput             `json:"node,omitempty"`
	And                        *UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         *UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        *UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

// UserCreateInput input struct docs
type UserCreateInput struct {
	Name              *string                                       `json:"name,omitempty"`
	Email             *string                                       `json:"email,omitempty"`
	Password          *string                                       `json:"password,omitempty"`
	ProfilePicture    *string                                       `json:"profilePicture,omitempty"`
	HomeLocation      *string                                       `json:"homeLocation,omitempty"`
	Bio               *string                                       `json:"bio,omitempty"`
	RequestsMade      *RequestCreateManyWithoutCreatedByInput       `json:"requestsMade,omitempty"`
	RequestsJoined    *RequestCreateManyWithoutInterestedUsersInput `json:"requestsJoined,omitempty"`
	IsVerified        *bool                                         `json:"isVerified,omitempty"`
	ShowNotifications *bool                                         `json:"showNotifications,omitempty"`
}

// RequestUpdateWithoutInterestedUsersDataInput input struct docs
type RequestUpdateWithoutInterestedUsersDataInput struct {
	CreatedBy      *UserUpdateOneRequiredWithoutRequestsMadeInput `json:"createdBy,omitempty"`
	Location       *string                                        `json:"location,omitempty"`
	Title          *string                                        `json:"title,omitempty"`
	Description    *string                                        `json:"description,omitempty"`
	Status         *Status                                        `json:"status,omitempty"`
	Comments       *CommentUpdateManyWithoutRequestInput          `json:"comments,omitempty"`
	SuggestedPrice *Price                                         `json:"suggestedPrice,omitempty"`
}

// UserUpsertWithoutRequestsMadeInput input struct docs
type UserUpsertWithoutRequestsMadeInput struct {
	Update *UserUpdateWithoutRequestsMadeDataInput `json:"update,omitempty"`
	Create *UserCreateWithoutRequestsMadeInput     `json:"create,omitempty"`
}

// NodeExec docs
type NodeExec struct {
	client Client
	stack  []Instruction
}

// Node docs - generated with types in GraphQLInterfaceType
type Node interface {
	ID() string
}

// UserPreviousValuesExec docs
type UserPreviousValuesExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance UserPreviousValuesExec) Exec() (UserPreviousValues, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData UserPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserPreviousValuesExecArray docs
type UserPreviousValuesExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance UserPreviousValuesExecArray) Exec() ([]UserPreviousValues, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []UserPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserPreviousValues docs - generated with types
type UserPreviousValues struct {
	ID                string `json:"id"`
	CreatedAt         string `json:"createdAt"`
	UpdatedAt         string `json:"updatedAt"`
	Name              string `json:"name,omitempty"`
	Email             string `json:"email"`
	Password          string `json:"password"`
	ProfilePicture    string `json:"profilePicture,omitempty"`
	HomeLocation      string `json:"homeLocation,omitempty"`
	Bio               string `json:"bio,omitempty"`
	IsVerified        bool   `json:"isVerified"`
	ShowNotifications bool   `json:"showNotifications"`
}

// BatchPayloadExec docs
type BatchPayloadExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance BatchPayloadExec) Exec() (BatchPayload, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData BatchPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// BatchPayloadExecArray docs
type BatchPayloadExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance BatchPayloadExecArray) Exec() ([]BatchPayload, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []BatchPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// BatchPayload docs - generated with types
type BatchPayload struct {
	Count int64 `json:"count"`
}

// RequestSubscriptionPayloadExec docs
type RequestSubscriptionPayloadExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *RequestSubscriptionPayloadExec) Node() *RequestExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Request",
			TypeFields: []string{"id", "createdAt", "location", "title", "description"},
		},
		Operation: "",
		Args:      args,
	})
	return &RequestExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// PreviousValues docs - executable for types
func (instance *RequestSubscriptionPayloadExec) PreviousValues() *RequestPreviousValuesExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "previousValues",
		Field: GraphQLField{
			Name:       "previousValues",
			TypeName:   "RequestPreviousValues",
			TypeFields: []string{"id", "createdAt", "location", "title", "description"},
		},
		Operation: "",
		Args:      args,
	})
	return &RequestPreviousValuesExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance RequestSubscriptionPayloadExec) Exec() (RequestSubscriptionPayload, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData RequestSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// RequestSubscriptionPayloadExecArray docs
type RequestSubscriptionPayloadExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance RequestSubscriptionPayloadExecArray) Exec() ([]RequestSubscriptionPayload, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []RequestSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// RequestSubscriptionPayload docs - generated with types
type RequestSubscriptionPayload struct {
	UpdatedFields string `json:"updatedFields,omitempty"`
}

// UserSubscriptionPayloadExec docs
type UserSubscriptionPayloadExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "User",
			TypeFields: []string{"id", "createdAt", "updatedAt", "name", "email", "password", "profilePicture", "homeLocation", "bio", "isVerified", "showNotifications"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// PreviousValues docs - executable for types
func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "previousValues",
		Field: GraphQLField{
			Name:       "previousValues",
			TypeName:   "UserPreviousValues",
			TypeFields: []string{"id", "createdAt", "updatedAt", "name", "email", "password", "profilePicture", "homeLocation", "bio", "isVerified", "showNotifications"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserPreviousValuesExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance UserSubscriptionPayloadExec) Exec() (UserSubscriptionPayload, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData UserSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserSubscriptionPayloadExecArray docs
type UserSubscriptionPayloadExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance UserSubscriptionPayloadExecArray) Exec() ([]UserSubscriptionPayload, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []UserSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserSubscriptionPayload docs - generated with types
type UserSubscriptionPayload struct {
	UpdatedFields string `json:"updatedFields,omitempty"`
}

// CommentConnectionExec docs
type CommentConnectionExec struct {
	client Client
	stack  []Instruction
}

// PageInfo docs - executable for types
func (instance *CommentConnectionExec) PageInfo() *PageInfoExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "pageInfo",
		Field: GraphQLField{
			Name:       "pageInfo",
			TypeName:   "PageInfo",
			TypeFields: []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &PageInfoExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Edges docs - executable for types
func (instance *CommentConnectionExec) Edges() *CommentEdgeExecArray {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "edges",
		Field: GraphQLField{
			Name:       "edges",
			TypeName:   "CommentEdge",
			TypeFields: []string{"cursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &CommentEdgeExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Aggregate docs - executable for types
func (instance *CommentConnectionExec) Aggregate() *AggregateCommentExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "aggregate",
		Field: GraphQLField{
			Name:       "aggregate",
			TypeName:   "AggregateComment",
			TypeFields: []string{"count"},
		},
		Operation: "",
		Args:      args,
	})
	return &AggregateCommentExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance CommentConnectionExec) Exec() (CommentConnection, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData CommentConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CommentConnectionExecArray docs
type CommentConnectionExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance CommentConnectionExecArray) Exec() ([]CommentConnection, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []CommentConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CommentConnection docs - generated with types
type CommentConnection struct {
}

// AggregateUserExec docs
type AggregateUserExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateUserExec) Exec() (AggregateUser, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData AggregateUser
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateUserExecArray docs
type AggregateUserExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateUserExecArray) Exec() ([]AggregateUser, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []AggregateUser
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateUser docs - generated with types
type AggregateUser struct {
	Count int32 `json:"count"`
}

// UserConnectionExec docs
type UserConnectionExec struct {
	client Client
	stack  []Instruction
}

// PageInfo docs - executable for types
func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "pageInfo",
		Field: GraphQLField{
			Name:       "pageInfo",
			TypeName:   "PageInfo",
			TypeFields: []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &PageInfoExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Edges docs - executable for types
func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "edges",
		Field: GraphQLField{
			Name:       "edges",
			TypeName:   "UserEdge",
			TypeFields: []string{"cursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserEdgeExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Aggregate docs - executable for types
func (instance *UserConnectionExec) Aggregate() *AggregateUserExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "aggregate",
		Field: GraphQLField{
			Name:       "aggregate",
			TypeName:   "AggregateUser",
			TypeFields: []string{"count"},
		},
		Operation: "",
		Args:      args,
	})
	return &AggregateUserExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance UserConnectionExec) Exec() (UserConnection, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData UserConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserConnectionExecArray docs
type UserConnectionExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance UserConnectionExecArray) Exec() ([]UserConnection, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []UserConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserConnection docs - generated with types
type UserConnection struct {
}

// RequestPreviousValuesExec docs
type RequestPreviousValuesExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance RequestPreviousValuesExec) Exec() (RequestPreviousValues, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData RequestPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// RequestPreviousValuesExecArray docs
type RequestPreviousValuesExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance RequestPreviousValuesExecArray) Exec() ([]RequestPreviousValues, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []RequestPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// RequestPreviousValues docs - generated with types
type RequestPreviousValues struct {
	ID          string `json:"id"`
	CreatedAt   string `json:"createdAt"`
	Location    string `json:"location"`
	Title       string `json:"title"`
	Description string `json:"description"`
}

// RequestEdgeExec docs
type RequestEdgeExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *RequestEdgeExec) Node() *RequestExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Request",
			TypeFields: []string{"id", "createdAt", "location", "title", "description"},
		},
		Operation: "",
		Args:      args,
	})
	return &RequestExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance RequestEdgeExec) Exec() (RequestEdge, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData RequestEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// RequestEdgeExecArray docs
type RequestEdgeExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance RequestEdgeExecArray) Exec() ([]RequestEdge, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []RequestEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// RequestEdge docs - generated with types
type RequestEdge struct {
	Cursor string `json:"cursor"`
}

// UserExec docs
type UserExec struct {
	client Client
	stack  []Instruction
}

type RequestsMadeParamsExec struct {
	Where   *RequestWhereInput
	OrderBy *RequestOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

// RequestsMade docs - executable for types
func (instance *UserExec) RequestsMade(params *RequestsMadeParamsExec) *RequestExecArray {
	var args []GraphQLArg

	if params != nil {

		if params.Where != nil {
			args = append(args, GraphQLArg{
				Name:     "where",
				Key:      "where",
				TypeName: "RequestWhereInput",
				Value:    params.Where,
			})
		}

		if params.OrderBy != nil {
			args = append(args, GraphQLArg{
				Name:     "orderBy",
				Key:      "orderBy",
				TypeName: "RequestOrderByInput",
				Value:    params.OrderBy,
			})
		}

		if params.Skip != nil {
			args = append(args, GraphQLArg{
				Name:     "skip",
				Key:      "skip",
				TypeName: "int32",
				Value:    params.Skip,
			})
		}

		if params.After != nil {
			args = append(args, GraphQLArg{
				Name:     "after",
				Key:      "after",
				TypeName: "string",
				Value:    params.After,
			})
		}

		if params.Before != nil {
			args = append(args, GraphQLArg{
				Name:     "before",
				Key:      "before",
				TypeName: "string",
				Value:    params.Before,
			})
		}

		if params.First != nil {
			args = append(args, GraphQLArg{
				Name:     "first",
				Key:      "first",
				TypeName: "int32",
				Value:    params.First,
			})
		}

		if params.Last != nil {
			args = append(args, GraphQLArg{
				Name:     "last",
				Key:      "last",
				TypeName: "int32",
				Value:    params.Last,
			})
		}

	}

	instance.stack = append(instance.stack, Instruction{
		Name: "requestsMade",
		Field: GraphQLField{
			Name:       "requestsMade",
			TypeName:   "Request",
			TypeFields: []string{"id", "createdAt", "location", "title", "description"},
		},
		Operation: "",
		Args:      args,
	})
	return &RequestExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

type RequestsJoinedParamsExec struct {
	Where   *RequestWhereInput
	OrderBy *RequestOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

// RequestsJoined docs - executable for types
func (instance *UserExec) RequestsJoined(params *RequestsJoinedParamsExec) *RequestExecArray {
	var args []GraphQLArg

	if params != nil {

		if params.Where != nil {
			args = append(args, GraphQLArg{
				Name:     "where",
				Key:      "where",
				TypeName: "RequestWhereInput",
				Value:    params.Where,
			})
		}

		if params.OrderBy != nil {
			args = append(args, GraphQLArg{
				Name:     "orderBy",
				Key:      "orderBy",
				TypeName: "RequestOrderByInput",
				Value:    params.OrderBy,
			})
		}

		if params.Skip != nil {
			args = append(args, GraphQLArg{
				Name:     "skip",
				Key:      "skip",
				TypeName: "int32",
				Value:    params.Skip,
			})
		}

		if params.After != nil {
			args = append(args, GraphQLArg{
				Name:     "after",
				Key:      "after",
				TypeName: "string",
				Value:    params.After,
			})
		}

		if params.Before != nil {
			args = append(args, GraphQLArg{
				Name:     "before",
				Key:      "before",
				TypeName: "string",
				Value:    params.Before,
			})
		}

		if params.First != nil {
			args = append(args, GraphQLArg{
				Name:     "first",
				Key:      "first",
				TypeName: "int32",
				Value:    params.First,
			})
		}

		if params.Last != nil {
			args = append(args, GraphQLArg{
				Name:     "last",
				Key:      "last",
				TypeName: "int32",
				Value:    params.Last,
			})
		}

	}

	instance.stack = append(instance.stack, Instruction{
		Name: "requestsJoined",
		Field: GraphQLField{
			Name:       "requestsJoined",
			TypeName:   "Request",
			TypeFields: []string{"id", "createdAt", "location", "title", "description"},
		},
		Operation: "",
		Args:      args,
	})
	return &RequestExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance UserExec) Exec() (User, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData User
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserExecArray docs
type UserExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance UserExecArray) Exec() ([]User, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []User
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// User docs - generated with types
type User struct {
	ID                string `json:"id"`
	CreatedAt         string `json:"createdAt"`
	UpdatedAt         string `json:"updatedAt"`
	Name              string `json:"name,omitempty"`
	Email             string `json:"email"`
	Password          string `json:"password"`
	ProfilePicture    string `json:"profilePicture,omitempty"`
	HomeLocation      string `json:"homeLocation,omitempty"`
	Bio               string `json:"bio,omitempty"`
	IsVerified        bool   `json:"isVerified"`
	ShowNotifications bool   `json:"showNotifications"`
}

// AggregateCommentExec docs
type AggregateCommentExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateCommentExec) Exec() (AggregateComment, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData AggregateComment
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateCommentExecArray docs
type AggregateCommentExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateCommentExecArray) Exec() ([]AggregateComment, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []AggregateComment
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateComment docs - generated with types
type AggregateComment struct {
	Count int32 `json:"count"`
}

// PageInfoExec docs
type PageInfoExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance PageInfoExec) Exec() (PageInfo, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData PageInfo
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// PageInfoExecArray docs
type PageInfoExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance PageInfoExecArray) Exec() ([]PageInfo, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []PageInfo
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// PageInfo docs - generated with types
type PageInfo struct {
	HasNextPage     bool   `json:"hasNextPage"`
	HasPreviousPage bool   `json:"hasPreviousPage"`
	StartCursor     string `json:"startCursor,omitempty"`
	EndCursor       string `json:"endCursor,omitempty"`
}

// CommentPreviousValuesExec docs
type CommentPreviousValuesExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance CommentPreviousValuesExec) Exec() (CommentPreviousValues, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData CommentPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CommentPreviousValuesExecArray docs
type CommentPreviousValuesExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance CommentPreviousValuesExecArray) Exec() ([]CommentPreviousValues, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []CommentPreviousValues
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CommentPreviousValues docs - generated with types
type CommentPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	Text      string `json:"text"`
}

// CommentSubscriptionPayloadExec docs
type CommentSubscriptionPayloadExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *CommentSubscriptionPayloadExec) Node() *CommentExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Comment",
			TypeFields: []string{"id", "createdAt", "text"},
		},
		Operation: "",
		Args:      args,
	})
	return &CommentExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// PreviousValues docs - executable for types
func (instance *CommentSubscriptionPayloadExec) PreviousValues() *CommentPreviousValuesExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "previousValues",
		Field: GraphQLField{
			Name:       "previousValues",
			TypeName:   "CommentPreviousValues",
			TypeFields: []string{"id", "createdAt", "text"},
		},
		Operation: "",
		Args:      args,
	})
	return &CommentPreviousValuesExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance CommentSubscriptionPayloadExec) Exec() (CommentSubscriptionPayload, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData CommentSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CommentSubscriptionPayloadExecArray docs
type CommentSubscriptionPayloadExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance CommentSubscriptionPayloadExecArray) Exec() ([]CommentSubscriptionPayload, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []CommentSubscriptionPayload
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CommentSubscriptionPayload docs - generated with types
type CommentSubscriptionPayload struct {
	UpdatedFields string `json:"updatedFields,omitempty"`
}

// CommentExec docs
type CommentExec struct {
	client Client
	stack  []Instruction
}

// CreatedBy docs - executable for types
func (instance *CommentExec) CreatedBy() *UserExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "createdBy",
		Field: GraphQLField{
			Name:       "createdBy",
			TypeName:   "User",
			TypeFields: []string{"id", "createdAt", "updatedAt", "name", "email", "password", "profilePicture", "homeLocation", "bio", "isVerified", "showNotifications"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Request docs - executable for types
func (instance *CommentExec) Request() *RequestExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "request",
		Field: GraphQLField{
			Name:       "request",
			TypeName:   "Request",
			TypeFields: []string{"id", "createdAt", "location", "title", "description"},
		},
		Operation: "",
		Args:      args,
	})
	return &RequestExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance CommentExec) Exec() (Comment, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData Comment
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CommentExecArray docs
type CommentExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance CommentExecArray) Exec() ([]Comment, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []Comment
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// Comment docs - generated with types
type Comment struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	Text      string `json:"text"`
}

// RequestExec docs
type RequestExec struct {
	client Client
	stack  []Instruction
}

// CreatedBy docs - executable for types
func (instance *RequestExec) CreatedBy() *UserExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "createdBy",
		Field: GraphQLField{
			Name:       "createdBy",
			TypeName:   "User",
			TypeFields: []string{"id", "createdAt", "updatedAt", "name", "email", "password", "profilePicture", "homeLocation", "bio", "isVerified", "showNotifications"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

type InterestedUsersParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

// InterestedUsers docs - executable for types
func (instance *RequestExec) InterestedUsers(params *InterestedUsersParamsExec) *UserExecArray {
	var args []GraphQLArg

	if params != nil {

		if params.Where != nil {
			args = append(args, GraphQLArg{
				Name:     "where",
				Key:      "where",
				TypeName: "UserWhereInput",
				Value:    params.Where,
			})
		}

		if params.OrderBy != nil {
			args = append(args, GraphQLArg{
				Name:     "orderBy",
				Key:      "orderBy",
				TypeName: "UserOrderByInput",
				Value:    params.OrderBy,
			})
		}

		if params.Skip != nil {
			args = append(args, GraphQLArg{
				Name:     "skip",
				Key:      "skip",
				TypeName: "int32",
				Value:    params.Skip,
			})
		}

		if params.After != nil {
			args = append(args, GraphQLArg{
				Name:     "after",
				Key:      "after",
				TypeName: "string",
				Value:    params.After,
			})
		}

		if params.Before != nil {
			args = append(args, GraphQLArg{
				Name:     "before",
				Key:      "before",
				TypeName: "string",
				Value:    params.Before,
			})
		}

		if params.First != nil {
			args = append(args, GraphQLArg{
				Name:     "first",
				Key:      "first",
				TypeName: "int32",
				Value:    params.First,
			})
		}

		if params.Last != nil {
			args = append(args, GraphQLArg{
				Name:     "last",
				Key:      "last",
				TypeName: "int32",
				Value:    params.Last,
			})
		}

	}

	instance.stack = append(instance.stack, Instruction{
		Name: "interestedUsers",
		Field: GraphQLField{
			Name:       "interestedUsers",
			TypeName:   "User",
			TypeFields: []string{"id", "createdAt", "updatedAt", "name", "email", "password", "profilePicture", "homeLocation", "bio", "isVerified", "showNotifications"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

type CommentsParamsExec struct {
	Where   *CommentWhereInput
	OrderBy *CommentOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

// Comments docs - executable for types
func (instance *RequestExec) Comments(params *CommentsParamsExec) *CommentExecArray {
	var args []GraphQLArg

	if params != nil {

		if params.Where != nil {
			args = append(args, GraphQLArg{
				Name:     "where",
				Key:      "where",
				TypeName: "CommentWhereInput",
				Value:    params.Where,
			})
		}

		if params.OrderBy != nil {
			args = append(args, GraphQLArg{
				Name:     "orderBy",
				Key:      "orderBy",
				TypeName: "CommentOrderByInput",
				Value:    params.OrderBy,
			})
		}

		if params.Skip != nil {
			args = append(args, GraphQLArg{
				Name:     "skip",
				Key:      "skip",
				TypeName: "int32",
				Value:    params.Skip,
			})
		}

		if params.After != nil {
			args = append(args, GraphQLArg{
				Name:     "after",
				Key:      "after",
				TypeName: "string",
				Value:    params.After,
			})
		}

		if params.Before != nil {
			args = append(args, GraphQLArg{
				Name:     "before",
				Key:      "before",
				TypeName: "string",
				Value:    params.Before,
			})
		}

		if params.First != nil {
			args = append(args, GraphQLArg{
				Name:     "first",
				Key:      "first",
				TypeName: "int32",
				Value:    params.First,
			})
		}

		if params.Last != nil {
			args = append(args, GraphQLArg{
				Name:     "last",
				Key:      "last",
				TypeName: "int32",
				Value:    params.Last,
			})
		}

	}

	instance.stack = append(instance.stack, Instruction{
		Name: "comments",
		Field: GraphQLField{
			Name:       "comments",
			TypeName:   "Comment",
			TypeFields: []string{"id", "createdAt", "text"},
		},
		Operation: "",
		Args:      args,
	})
	return &CommentExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance RequestExec) Exec() (Request, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData Request
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// RequestExecArray docs
type RequestExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance RequestExecArray) Exec() ([]Request, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []Request
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// Request docs - generated with types
type Request struct {
	ID          string `json:"id"`
	CreatedAt   string `json:"createdAt"`
	Location    string `json:"location"`
	Title       string `json:"title"`
	Description string `json:"description"`
}

// UserEdgeExec docs
type UserEdgeExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *UserEdgeExec) Node() *UserExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "User",
			TypeFields: []string{"id", "createdAt", "updatedAt", "name", "email", "password", "profilePicture", "homeLocation", "bio", "isVerified", "showNotifications"},
		},
		Operation: "",
		Args:      args,
	})
	return &UserExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance UserEdgeExec) Exec() (UserEdge, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData UserEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserEdgeExecArray docs
type UserEdgeExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance UserEdgeExecArray) Exec() ([]UserEdge, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []UserEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// UserEdge docs - generated with types
type UserEdge struct {
	Cursor string `json:"cursor"`
}

// CommentEdgeExec docs
type CommentEdgeExec struct {
	client Client
	stack  []Instruction
}

// Node docs - executable for types
func (instance *CommentEdgeExec) Node() *CommentExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "node",
		Field: GraphQLField{
			Name:       "node",
			TypeName:   "Comment",
			TypeFields: []string{"id", "createdAt", "text"},
		},
		Operation: "",
		Args:      args,
	})
	return &CommentExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance CommentEdgeExec) Exec() (CommentEdge, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData CommentEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CommentEdgeExecArray docs
type CommentEdgeExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance CommentEdgeExecArray) Exec() ([]CommentEdge, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []CommentEdge
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// CommentEdge docs - generated with types
type CommentEdge struct {
	Cursor string `json:"cursor"`
}

// RequestConnectionExec docs
type RequestConnectionExec struct {
	client Client
	stack  []Instruction
}

// PageInfo docs - executable for types
func (instance *RequestConnectionExec) PageInfo() *PageInfoExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "pageInfo",
		Field: GraphQLField{
			Name:       "pageInfo",
			TypeName:   "PageInfo",
			TypeFields: []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &PageInfoExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Edges docs - executable for types
func (instance *RequestConnectionExec) Edges() *RequestEdgeExecArray {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "edges",
		Field: GraphQLField{
			Name:       "edges",
			TypeName:   "RequestEdge",
			TypeFields: []string{"cursor"},
		},
		Operation: "",
		Args:      args,
	})
	return &RequestEdgeExecArray{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Aggregate docs - executable for types
func (instance *RequestConnectionExec) Aggregate() *AggregateRequestExec {
	var args []GraphQLArg

	instance.stack = append(instance.stack, Instruction{
		Name: "aggregate",
		Field: GraphQLField{
			Name:       "aggregate",
			TypeName:   "AggregateRequest",
			TypeFields: []string{"count"},
		},
		Operation: "",
		Args:      args,
	})
	return &AggregateRequestExec{
		client: instance.client,
		stack:  instance.stack,
	}
}

// Exec docs
func (instance RequestConnectionExec) Exec() (RequestConnection, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData RequestConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// RequestConnectionExecArray docs
type RequestConnectionExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance RequestConnectionExecArray) Exec() ([]RequestConnection, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []RequestConnection
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// RequestConnection docs - generated with types
type RequestConnection struct {
}

// AggregateRequestExec docs
type AggregateRequestExec struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateRequestExec) Exec() (AggregateRequest, error) {
	var allArgs []GraphQLArg
	variables := make(map[string]interface{})
	for instructionKey := range instance.stack {
		instruction := &instance.stack[instructionKey]
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for argKey := range instruction.Args {
			arg := &instruction.Args[argKey]
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			isUnique := false
			for isUnique == false {
				isUnique = true
				for key, existingArg := range allArgs {
					if existingArg.Name == arg.Name {
						isUnique = false
						arg.Name = arg.Name + "_" + strconv.Itoa(key)
						if instance.client.Debug {
							fmt.Println("Resolving Collision Arg Name: ", arg.Name)
						}
						break
					}
				}
			}
			if instance.client.Debug {
				fmt.Println("Arg Name: ", arg.Name)
			}
			allArgs = append(allArgs, *arg)
			variables[arg.Name] = arg.Value
		}
	}
	query := instance.client.ProcessInstructions(instance.stack)
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData AggregateRequest
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateRequestExecArray docs
type AggregateRequestExecArray struct {
	client Client
	stack  []Instruction
}

// Exec docs
func (instance AggregateRequestExecArray) Exec() ([]AggregateRequest, error) {
	query := instance.client.ProcessInstructions(instance.stack)
	variables := make(map[string]interface{})
	for _, instruction := range instance.stack {
		if instance.client.Debug {
			fmt.Println("Instruction Exec: ", instruction)
		}
		for _, arg := range instruction.Args {
			if instance.client.Debug {
				fmt.Println("Instruction Arg Exec: ", instruction)
			}
			variables[arg.Name] = arg.Value
		}
	}
	if instance.client.Debug {
		fmt.Println("Query Exec:", query)
		fmt.Println("Variables Exec:", variables)
	}
	data, err := instance.client.GraphQL(query, variables)
	if instance.client.Debug {
		fmt.Println("Data Exec:", data)
		fmt.Println("Error Exec:", err)
	}

	var genericData interface{} // This can handle both map[string]interface{} and []interface[]

	// Is unpacking needed
	dataType := reflect.TypeOf(data)
	if !isArray(dataType) {
		unpackedData := data
		for _, instruction := range instance.stack {
			if instance.client.Debug {
				fmt.Println("Original Unpacked Data Step Exec:", unpackedData)
			}
			if isArray(unpackedData[instruction.Name]) {
				genericData = (unpackedData[instruction.Name]).([]interface{})
				break
			} else {
				unpackedData = (unpackedData[instruction.Name]).(map[string]interface{})
			}
			if instance.client.Debug {
				fmt.Println("Partially Unpacked Data Step Exec:", unpackedData)
			}
			if instance.client.Debug {
				fmt.Println("Unpacked Data Step Instruction Exec:", instruction.Name)
				fmt.Println("Unpacked Data Step Exec:", unpackedData)
				fmt.Println("Unpacked Data Step Type Exec:", reflect.TypeOf(unpackedData))
			}
			genericData = unpackedData
		}
	}
	if instance.client.Debug {
		fmt.Println("Data Unpacked Exec:", genericData)
	}

	var decodedData []AggregateRequest
	mapstructure.Decode(genericData, &decodedData)
	if instance.client.Debug {
		fmt.Println("Data Exec Decoded:", decodedData)
	}
	return decodedData, err
}

// AggregateRequest docs - generated with types
type AggregateRequest struct {
	Count int32 `json:"count"`
}

// GraphQL Send a GraphQL operation request
func (client Client) GraphQL(query string, variables map[string]interface{}) (map[string]interface{}, error) {
	// TODO: Add auth support

	req := graphql.NewRequest(query)
	gqlClient := graphql.NewClient(
		(map[bool]string{true: client.Endpoint, false: "`http://localhost:4466`"})[client.Endpoint != ""],
	)

	for key, value := range variables {
		req.Var(key, value)
	}

	ctx := context.Background()

	// var respData ResponseStruct
	var respData map[string]interface{}
	if err := gqlClient.Run(ctx, req, &respData); err != nil {
		if client.Debug {
			fmt.Println("GraphQL Response:", respData)
		}
		return nil, err
	}
	return respData, nil
}
